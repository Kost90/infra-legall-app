version: "3.8"

services:
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: backend
    restart: unless-stopped
    env_file: .env
    environment:
      NODE_ENV: production
      PORT: ${BACKEND_PORT:-3030}
      DB_HOST: udocument-do-user-24626001-0.d.db.ondigitalocean.com
      DB_PORT: 25060
      DB_USER: doadmin
      DB_PASSWORD: ${DB_PASSWORD} # укажи в .env
      DB_NAME: defaultdb
      DB_SSL: "true"
      # или можно одной строкой, если твой backend это поддерживает:
      # DATABASE_URL: postgresql://doadmin:${DB_PASSWORD}@udocument-do-user-24626001-0.d.db.ondigitalocean.com:25060/defaultdb?sslmode=require
      PUPPETEER_ARGS: "--no-sandbox --disable-setuid-sandbox"
    expose:
      - "${BACKEND_PORT:-3030}"
    networks:
      - app_net

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    container_name: frontend
    restart: unless-stopped
    env_file: .env
    environment:
      NODE_ENV: production
      PORT: ${FRONTEND_PORT:-3000}
      NEXT_PUBLIC_API_URL: ${NEXT_PUBLIC_API_URL:-/api}
    expose:
      - "${FRONTEND_PORT:-3000}"
    networks:
      - app_net

  nginx:
    image: nginx:1.25-alpine
    container_name: nginx
    restart: unless-stopped
    depends_on:
      - frontend
      - backend
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/conf.d:/etc/nginx/conf.d:ro
      - nginx-certbot-www:/var/www/certbot
      - certbot-etc:/etc/letsencrypt
    networks:
      - app_net

  certbot:
    image: certbot/certbot:latest
    container_name: certbot
    volumes:
      - certbot-etc:/etc/letsencrypt
      - nginx-certbot-www:/var/www/certbot
    command: sh -c 'trap exit TERM; while :; do certbot renew --webroot -w /var/www/certbot --quiet && echo "Certs renewed"; sleep 12h; done'
    networks:
      - app_net

volumes:
  certbot-etc:
  nginx-certbot-www:

networks:
  app_net:
    driver: bridge
# version: "3.8"

# services:
#   db:
#     image: postgres:16-alpine
#     container_name: db
#     restart: unless-stopped
#     env_file: .env
#     environment:
#       POSTGRES_USER: ${POSTGRES_USER} # задаются в .env
#       POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
#       POSTGRES_DB: ${POSTGRES_DB}
#     volumes:
#       - pg_data:/var/lib/postgresql/data
#     healthcheck:
#       test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
#       interval: 5s
#       timeout: 3s
#       retries: 10
#     networks:
#       - app_net

#   backend:
#     build:
#       context: ./backend
#       dockerfile: Dockerfile
#     container_name: backend
#     restart: unless-stopped
#     depends_on:
#       db:
#         condition: service_healthy
#     env_file: .env
#     environment:
#       NODE_ENV: production
#       PORT: ${BACKEND_PORT:-3030}
#       # Параметры подключения к БД (TypeORM читает по твоей конфигурации)
#       DB_HOST: db
#       DB_PORT: 5432
#       DB_USER: ${POSTGRES_USER}
#       DB_PASSWORD: ${POSTGRES_PASSWORD}
#       DB_NAME: ${POSTGRES_DB}
#       # Для puppeteer — безопасный запуск без песочницы
#       PUPPETEER_ARGS: "--no-sandbox --disable-setuid-sandbox"
#     expose:
#       - "${BACKEND_PORT:-3030}"
#     networks:
#       - app_net

#   frontend:
#     build:
#       context: ./frontend
#       dockerfile: Dockerfile
#     container_name: frontend
#     restart: unless-stopped
#     env_file: .env
#     environment:
#       NODE_ENV: production
#       PORT: ${FRONTEND_PORT:-3000}
#       # Публичный адрес API. Варианты:
#       # - Если используешь поддомен: https://api.moysait.com
#       # - Если проксируешь /api на тот же домен: /api
#       NEXT_PUBLIC_API_URL: ${NEXT_PUBLIC_API_URL:-/api}
#     expose:
#       - "${FRONTEND_PORT:-3000}"
#     networks:
#       - app_net

#   nginx:
#     image: nginx:1.25-alpine
#     container_name: nginx
#     restart: unless-stopped
#     depends_on:
#       - frontend
#       - backend
#     ports:
#       - "80:80"
#       - "443:443"
#     volumes:
#       # Конфиги nginx
#       - ./nginx/conf.d:/etc/nginx/conf.d:ro
#       # ACME-challenge webroot
#       - nginx-certbot-www:/var/www/certbot
#       # Сертификаты Let's Encrypt
#       - certbot-etc:/etc/letsencrypt
#     networks:
#       - app_net

#   certbot:
#     image: certbot/certbot:latest
#     container_name: certbot
#     # Никаких портов — работает через общий webroot с nginx
#     volumes:
#       - certbot-etc:/etc/letsencrypt
#       - nginx-certbot-www:/var/www/certbot
#     # Фоновое автообновление (первичный выпуск сертификатов см. ниже)
#     command: sh -c 'trap exit TERM; while :; do certbot renew --webroot -w /var/www/certbot --quiet && echo "Certs renewed"; sleep 12h; done'
#     networks:
#       - app_net

# volumes:
#   pg_data:
#   certbot-etc:
#   nginx-certbot-www:

# networks:
#   app_net:
#     driver: bridge
# #new gpt:
# version: "3.9"

# name: legalapp_stack

# networks:
#   app-net:
#     driver: bridge

# volumes:
#   pg_data:
#   certbot_www:
#   letsencrypt:

# services:
#   db:
#     image: postgres:16-alpine
#     container_name: legalapp-postgres
#     restart: unless-stopped
#     environment:
#       POSTGRES_USER: ${POSTGRES_USER}
#       POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
#       POSTGRES_DB: ${POSTGRES_DB}
#     volumes:
#       - pg_data:/var/lib/postgresql/data
#     healthcheck:
#       test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB} -h 127.0.0.1"]
#       interval: 5s
#       timeout: 3s
#       retries: 10
#     networks:
#       - app-net

#   backend:
#     build:
#       context: ../backend
#       dockerfile: Dockerfile
#     container_name: legalapp-backend
#     restart: unless-stopped
#     depends_on:
#       db:
#         condition: service_healthy
#     env_file:
#       - ../backend/.env
#     environment:
#       # Бэкенду важно знать, как достучаться до БД внутри сети compose:
#       DB_HOST: db
#       DB_PORT: 5432
#       # Остальные DB_* подтянутся из ../backend/.env
#       PORT: 3030
#       NODE_ENV: production
#     networks:
#       - app-net
#     # Не публикуем порт наружу — только через nginx
#     expose:
#       - "3030"

#   frontend:
#     build:
#       context: ../frontend
#       dockerfile: Dockerfile
#     container_name: legalapp-frontend
#     restart: unless-stopped
#     environment:
#       NODE_ENV: production
#       PORT: 3000
#       # URL API для браузера. Если используете роут /api через тот же домен — можно NEXT_PUBLIC_API_URL=https://moysait.com/api
#       NEXT_PUBLIC_API_URL: https://api.moysait.com
#     networks:
#       - app-net
#     expose:
#       - "3000"

#   nginx:
#     image: nginx:1.27-alpine
#     container_name: legalapp-nginx
#     restart: unless-stopped
#     depends_on:
#       - frontend
#       - backend
#     ports:
#       - "80:80"
#       - "443:443"
#     volumes:
#       # HTTP и HTTPS конфиги
#       - ./nginx/default.conf:/etc/nginx/conf.d/default.conf:ro
#       - ./nginx/default-ssl.conf:/etc/nginx/conf.d/default-ssl.conf:ro
#       # Webroot для ACME-challenge
#       - certbot_www:/var/www/certbot
#       # Сертификаты Let’s Encrypt
#       - letsencrypt:/etc/letsencrypt
#     networks:
#       - app-net

#   certbot:
#     image: certbot/certbot:latest
#     container_name: legalapp-certbot
#     # Контейнер будет периодически пытаться обновлять сертификаты,
#     # nginx мы перезагрузим через docker exec из cron-хоста/ручной команды
#     volumes:
#       - certbot_www:/var/www/certbot
#       - letsencrypt:/etc/letsencrypt
#     entrypoint: sh
#     command: -c "trap 'exit 0' TERM; while :; do certbot renew --webroot -w /var/www/certbot --quiet; sleep 12h; done"
#     networks:
#       - app-net

# # gemini:
# # Указываем версию синтаксиса Docker Compose. 3.9 - одна из последних стабильных.
# version: '3.9'

# services:
#   # --- СЕРВИС БАЗЫ ДАННЫХ (POSTGRESQL) ---
#   db:
#     image: postgres:15-alpine # Используем официальный, легковесный образ PostgreSQL.
#     container_name: my_app_db
#     restart: unless-stopped # Перезапускать контейнер, если он остановился, но не при остановке Docker.
#     volumes:
#       - pg_data:/var/lib/postgresql/data # Сохраняем данные БД на хост-машине в именованном томе.
#     env_file:
#       - .env # Загружаем переменные окружения из файла .env в корне проекта.
#     environment:
#       # Эти переменные используются образом Postgres для инициализации БД.
#       - POSTGRES_USER=${POSTGRES_USER}
#       - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
#       - POSTGRES_DB=${POSTGRES_DB}
#     networks:
#       - my_app_network # Подключаем к нашей общей сети.
#     healthcheck:
#       # Проверка, что база данных готова принимать подключения.
#       test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
#       interval: 5s
#       timeout: 5s
#       retries: 5

#   # --- СЕРВИС БЭКЕНДА (NEST.JS) ---
#   backend:
#     build:
#       context: ./backend # Указываем путь к папке с Dockerfile бэкенда.
#       dockerfile: Dockerfile
#     container_name: my_app_backend
#     restart: unless-stopped
#     env_file:
#       - ./backend/.env # Загружаем переменные для самого приложения Nest.js.
#     depends_on:
#       db:
#         condition: service_healthy # Запускать бэкенд только после того, как БД будет готова.
#     networks:
#       - my_app_network

#   # --- СЕРВИС ФРОНТЕНДА (NEXT.JS) ---
#   frontend:
#     build:
#       context: ./frontend # Указываем путь к папке с Dockerfile фронтенда.
#       dockerfile: Dockerfile
#     container_name: my_app_frontend
#     restart: unless-stopped
#     networks:
#       - my_app_network

#   # --- СЕРВИС REVERSE PROXY (NGINX) ---
#   nginx:
#     image: nginx:stable-alpine
#     container_name: my_app_nginx
#     restart: unless-stopped
#     ports:
#       # Пробрасываем порты 80 и 443 с хост-машины в контейнер.
#       - "80:80"
#       - "443:443"
#     volumes:
#       # Монтируем нашу конфигурацию Nginx.
#       - ./nginx/default.conf:/etc/nginx/conf.d/default.conf
#       # Монтируем папки для SSL-сертификатов от Certbot.
#       - ./certbot/conf:/etc/letsencrypt
#       - ./certbot/www:/var/www/html
#     depends_on:
#       - frontend
#       - backend
#     networks:
#       - my_app_network

#   # --- СЕРВИС ДЛЯ SSL-СЕРТИФИКАТОВ (CERTBOT) ---
#   certbot:
#     image: certbot/certbot
#     container_name: my_app_certbot
#     volumes:
#       # Те же папки, что и у Nginx, чтобы Certbot мог создавать сертификаты.
#       - ./certbot/conf:/etc/letsencrypt
#       - ./certbot/www:/var/www/html

# # --- ИМЕНОВАННЫЕ ТОМА (VOLUMES) ---
# # Docker будет управлять этими томами.
# volumes:
#   pg_data:

# # --- СЕТИ (NETWORKS) ---
# # Создаем общую сеть, чтобы контейнеры могли общаться друг с другом по именам сервисов.
# networks:
#   my_app_network:
#     driver: bridge
